{"version":3,"file":"ui.min.js","sources":["../src/ui.js"],"sourcesContent":["// This file is part of Moodle - https://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * Commands for the plugin logic of the Moodle tiny_multilang2 plugin.\n *\n * @module      tiny_multilang2\n * @author      Iñaki Arenaza <iarenaza@mondragon.edu>\n * @author      Stephan Robotta <stephan.robotta@bfh.ch>\n * @author      Tai Le Tan <dev.tailetan@gmail.com>\n * @copyright   2015 onwards Iñaki Arenaza & Mondragon Unibertsitatea\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {getHighlightCss, isContentToHighlight, mlangFilterExists} from './options';\nimport {isNull, trim, blockTags, spanMultilangBegin, spanMultilangEnd} from './constants';\nimport {parseEditorContent} from './htmlparser';\n/**\n * Marker to remember that the submit button was hit.\n * @type {boolean}\n * @private\n */\nlet _isSubmit = false;\n\n/**\n * @type {object}\n * @private\n */\nconst _options = {};\n\n/**\n * Convert {mlang xx} and {mlang} strings to spans, so we can style them visually.\n * Remove superflous whitespace while at it.\n * @param {tinymce.Editor} ed\n * @return {string}\n */\nconst addVisualStyling = function(ed) {\n\n    // Parse the editor content and check for all {mlang} tags that are in the html content.\n    let content = parseEditorContent(ed.getContent());\n\n    // Check for the traditional <span class=\"multilang\"> tags, in case these were used as well in the text.\n    // Any <span class=\"multilang\"> tag must be replaced with a <span class=\"multilang-begin...>{mlang XX}</span>\n    // and the corresponding closing </span> must be replaced by <span class=\"multilang-end ...>{mlang}</span>.\n    // To handle this, we must convert the string into a DOMDocument so that any span.multilang tag can be searched\n    // and replaced.\n    const dom = new DOMParser();\n    const doc = dom.parseFromString(content, 'text/html');\n    if (doc.children.length === 0) { // Should not happen, but anyway, keep the check.\n        return content;\n    }\n    const nodes = doc.querySelectorAll('span.multilang');\n    if (nodes.length === 0) {\n        return content;\n    }\n    for (const span of nodes) {\n        const newSpan = spanMultilangBegin\n            .replace(new RegExp('%lang', 'g'), span.getAttribute('lang'))\n            .replace('mceNonEditable', 'mceNonEditable fallback')\n          + span.innerHTML\n          + spanMultilangEnd\n            .replace('mceNonEditable', 'mceNonEditable fallback');\n        // Insert the replacement string after the span tag itself by converting it into a html fragment.\n        span.insertAdjacentHTML('afterend', newSpan);\n        // Once the new tags are placed at the correct position, we can remove the original span tag.\n        span.remove();\n    }\n    // Convert the DOMDocument into a string again.\n    return doc.getElementsByTagName('body')[0].innerHTML;\n};\n\n/**\n * Remove the spans we added in _add_visual_styling() to leave only the {mlang xx} and {mlang} tags.\n * Also make sure we lowercase the multilang 'tags'\n * @param {tinymce.Editor} ed\n */\nconst removeVisualStyling = function(ed) {\n    ['begin', 'end'].forEach(function(t) {\n        for (const span of ed.dom.select('span.multilang-' + t)) {\n            if (t === 'begin' && span.classList.contains('fallback')) {\n                // This placeholder tag was created from an oldstyle <span class=\"multilang\"> tag.\n                let innerHTML = '';\n                let end = span;\n                let toRemove = [];\n                // Search the corresponding closing tag.\n                while (end) {\n                    end = end.nextSibling;\n                    if (isNull(end)) { // Got a parent that does not exist. Stop here.\n                        break;\n                    }\n                    if (!isNull(end.classList) && end.classList.contains('multilang-end')) {\n                        // We found the multilang-end node, that needs to be removed, and also, we can stop here.\n                        toRemove.push(end);\n                        break;\n                    }\n                    // Sibling inside the tags need to be preserved, but moved to the innerHTML of the real\n                    // span tag. Therefore, collect the node content as string and remember the real nodes\n                    // to remove them later.\n                    if (end.nodeType === 3) {\n                        innerHTML += end.nodeValue;\n                    } else if (end.nodeType === 1) {\n                        innerHTML += end.outerHTML;\n                    }\n                    toRemove.push(end);\n                }\n                if (!isNull(end)) {\n                    // Extract the language from the {mlang XX} tag.\n                    const lang = span.innerHTML.match(new RegExp('{\\\\s*mlang\\\\s+([^}]+?)\\\\s*}', 'i'));\n                    if (lang) {\n                        /* Do not add the dir attribute as it breaks the Moodle language filter.\n                        // Right to left default languages.\n                        const rtlLanguages = getRTLLanguages();\n                        const langCode = lang[1];\n                        // Add dir=\"rtl\" to the html tag any time the overall document direction is right-to-left.\n                        const dir = rtlLanguages.includes(langCode) ? 'rtl' : 'ltr';\n                        // Do not add the dir attribute as it breaks the Moodle language filter.\n                        const newHTML = `<span class=\"multilang\" lang=\"${lang[1]}\" dir=\"${dir}\">${innerHTML}</span>`;\n                        */\n                        const newHTML = `<span class=\"multilang\" lang=\"${lang[1]}\">${innerHTML}</span>`;\n                        ed.dom.setOuterHTML(span, newHTML);\n                        // And remove the other siblings.\n                        for (end of toRemove) {\n                            ed.dom.remove(end);\n                        }\n                    }\n                }\n            } else {\n                // Normal placeholder tag, just restore the innerHTML that is {mlang XX} or {mlang}-\n                ed.dom.setOuterHTML(span, span.innerHTML.toLowerCase());\n            }\n        }\n    });\n};\n\n/**\n * At the current selection lookup for the current node. If we are inside a special span that\n * encapsulates the {lang} tag, then look for the corresponding opening or closing tag,\n * depending on what's set in the search param.\n * @param {tinymce.Editor} ed\n * @param {string} search\n * @return {Node|null} The encapsulating span tag if found.\n */\nconst getHighlightNodeFromSelect = function(ed, search) {\n    let span;\n    ed.dom.getParents(ed.selection.getStart(), elm => {\n        // Are we in a span that highlights the lang tag.\n        if (!isNull(elm.classList)) {\n            // If we are on an opening/closing lang tag, we need to search for the\n            // corresponding closing/opening tag.\n            const counterpart = search === 'begin' ? 'end' : 'begin';\n            if (elm.classList.contains('multilang-' + counterpart)) {\n                // If we look for begin, go back the document, otherwise go down the doccument.\n                // Search for the next corresponding tag in the complete hierarchy.\n                span = search === 'begin' ? findClosestAncestor(ed, elm) : findClosestSuccessor(ed, elm);\n            } else if (elm.classList.contains('multilang-' + search)) {\n                // We are already on the correct tag we search for\n                span = elm;\n            }\n        }\n    });\n    return span;\n};\n\n/**\n * Find the closest ancestor span that is a multilang-begin span in relation to the given\n * span.multilang-end tag.\n * @param {tinymce.Editor} ed\n * @param {Node} node\n * @returns {Node|null}\n */\nconst findClosestAncestor = function(ed, node) {\n    const nodeList = ed.dom.select('span.multilang-begin, span.multilang-end');\n    for (let i = 0; i < nodeList.length; i++) {\n        if (nodeList[i] === node && i > 0 &&\n            isMultilangTag(nodeList[i - 1], 'begin')\n        ) {\n            return nodeList[i - 1];\n        }\n    }\n    return null;\n};\n\n/**\n * Find the closest successor span that is a multilang-end span in relation to the given\n * span.multilang-begin tag.\n * @param {tinymce.Editor} ed\n * @param {Node} node\n * @returns {Node|null}\n */\nconst findClosestSuccessor = function(ed, node) {\n    const nodeList = ed.dom.select('span.multilang-begin, span.multilang-end');\n    for (let i = 0; i < nodeList.length; i++) {\n        if (nodeList[i] === node && i < nodeList.length - 1 &&\n            isMultilangTag(nodeList[i + 1], 'end')\n        ) {\n            return nodeList[i + 1];\n        }\n    }\n    return null;\n};\n\n/**\n * Returns true if the given node is a multilang (begin|end) tag by checking whether the\n * appropriate class is set.\n * @param {Node} node\n * @param {string} search\n * @returns {boolean}\n */\nconst isMultilangTag = function(node, search) {\n    return !isNull(node.classList) && node.classList.contains('multilang-' + search);\n};\n\n/**\n * From the given text (that is derived from a selection) we try to check if we have block elements selected and\n * in case yes, how many.\n * Return an object with:\n *  el: the first block element node from the string\n *  cnt: number of block elements found on the first level\n * In case the text fragment is not valid parsable HTML, then null and 0 is returned.\n * @param {string} text\n * @return {object}\n */\nconst getBlockElement = function(text) {\n    let result = {el: null, cnt: 0};\n    const dom = new DOMParser();\n    const body = dom.parseFromString(text, 'text/html').body;\n    // If the children nodes start with no block element, then just quit here.\n    if (body.firstChild.nodeType !== Node.ELEMENT_NODE) {\n        return result;\n    }\n    // Lang tags should be placed inside block elements.\n    for (let i = 0; i < body.children.length; i++) {\n        if (body.children[i].nodeType !== Node.ELEMENT_NODE) {\n            continue;\n        }\n        if (blockTags.indexOf(body.children[i].tagName.toString().toLowerCase()) !== -1) {\n            result.cnt += 1;\n            if (isNull(result.el)) {\n                result.el = body.children[i];\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Check for the parent hierarchy elements, if there's a context toolbar container, then hide it.\n * @param {Node} el\n */\nconst hideContentToolbar = function(el) {\n    while (!isNull(el)) {\n        if (el.nodeType === Node.ELEMENT_NODE &&\n            !isNull(el.getAttribute('class')) &&\n            el.getAttribute('class').indexOf('tox-pop-') != -1\n        ) {\n            el.style.display = 'none';\n            return;\n        }\n        el = el.parentNode;\n    }\n};\n\n/**\n * When loading the editor for the first time, add the spans for highlighting the lang tags.\n * These are highlighted with the appropriate css only.\n * In addition pass some options to the plugin instance.\n * @param {tinymce.Editor} ed\n * @param {object} options\n */\nconst onInit = function(ed, options) {\n    Object.keys(options).forEach(function(key) {\n        _options[key] = options[key];\n    });\n    ed.setContent(addVisualStyling(ed));\n    if (isContentToHighlight(ed)) {\n        ed.dom.addStyle(getHighlightCss(ed));\n    }\n};\n\n/**\n * When the source code view dialogue is show, we must remove the highlight spans from the editor content\n * and also add them again when the dialogue is closed.\n * @param {tinymce.Editor} ed\n * @param {object} content\n */\nconst onBeforeGetContent = function(ed, content) {\n    if (!isNull(content.source_view) && content.source_view === true) {\n        // If the user clicks on 'Cancel' or the close button on the html\n        // source code dialog view, make sure we re-add the visual styling.\n        const onClose = function(ed) {\n            ed.off('close', onClose);\n            ed.setContent(addVisualStyling(ed));\n        };\n        const observer = new MutationObserver((mutations, obs) => {\n            const viewSrcModal = document.querySelector('[data-region=\"modal\"]');\n            if (viewSrcModal) {\n                viewSrcModal.addEventListener('click', (event) => {\n                    const {action} = event.target.dataset;\n                    if (['cancel', 'save', 'hide'].includes(action)) {\n                        onClose(ed);\n                    }\n                });\n                // Stop observing once the modal is found.\n                obs.disconnect();\n                return;\n            }\n            const tinyMceModal = document.querySelector('.tox-dialog-wrap');\n            if (tinyMceModal) {\n                ed.on('CloseWindow', () => {\n                    onClose(ed);\n                });\n                obs.disconnect();\n            }\n        });\n        observer.observe(document.body, {childList: true, subtree: true});\n        removeVisualStyling(ed);\n    }\n};\n\n/**\n * When the submit button is hit, the marker spans are removed. However, if there's an error\n * in saving the content (via ajax) the editor remains with the cleaned content. Therefore,\n * we need to add the marker span elements once again when the user tries to change the content\n * of the editor.\n * @param {tinymce.Editor} ed\n */\nconst onFocus = function(ed) {\n    if (_isSubmit) {\n        // eslint-disable-next-line camelcase\n        ed.setContent(addVisualStyling(ed), {no_events: true});\n        _isSubmit = false;\n    }\n};\n\n/**\n * Fires when the form containing the editor is submitted. Remove all the marker span elements.\n * @param {tinymce.Editor} ed\n */\nconst onSubmit = function(ed) {\n    removeVisualStyling(ed);\n    _isSubmit = true;\n};\n\n/**\n * Check for key press <del> when something is deleted. If that happens inside a highlight span\n * tag, then remove this tag and the corresponding that open/closes this lang tag.\n * @param {tinymce.Editor} ed\n * @param {Object} event\n */\nconst onDelete = function(ed, event) {\n    // We are not in composing mode, have not clicked and key <del> or <backspace> was not pressed.\n    if (event.isComposing || (isNull(event.clientX) && event.keyCode !== 46 && event.keyCode !== 8)) {\n        return;\n    }\n    // In case we clicked, check that we clicked an icon (this must have been the trash icon in the context menu).\n    if (!isNull(event.clientX) &&\n        (event.target.nodeType !== Node.ELEMENT_NODE || (event.target.nodeName !== 'path' && event.target.nodeName !== 'svg'))) {\n        return;\n    }\n    // Conditions match either key <del> or <backspace> was pressed, or an click on an svg icon was done.\n    // Check if we are inside a span for the language tag.\n    const begin = getHighlightNodeFromSelect(ed, 'begin');\n    const end = getHighlightNodeFromSelect(ed, 'end');\n    // Only if both, start and end tags are found, then delete the nodes here and prevent the default handling\n    // because the stuff to be deleted is already gone.\n    if (!isNull(begin) && !isNull(end)) {\n        event.preventDefault();\n        ed.dom.remove(begin);\n        ed.dom.remove(end);\n        if (!isNull(event.clientX)) {\n            hideContentToolbar(event.target);\n        }\n        cleanupBogus(ed);\n    }\n};\n\n/**\n * In the tinyMCE of Moodle 4.1 and 4.2 some leftovers from the element selection can be seen when the source code\n * is displayed. Remove these. Apparently 4.3 does not have this problem anymore.\n * @param {tinymce.Editor} ed\n */\nconst cleanupBogus = function(ed) {\n    for (const span of ed.dom.select('span[class*=\"multilang\"')) {\n        const p = span.parentElement;\n        if (!isNull(p.classList) && p.classList.contains('mce-offscreen-selection')) {\n            ed.dom.remove(p);\n        }\n    }\n};\n\n/**\n * The action when a language icon or menu entry is clicked. This adds the {mlang} tags at the current content\n * position or around the selection.\n * @param {tinymce.Editor} ed\n * @param {string} iso\n * @param {Event} event\n */\nconst applyLanguage = function(ed, iso, event) {\n    if (isNull(iso)) {\n        return;\n    }\n    if (iso === \"remove\") {\n        const elements = ed.contentDocument.body;\n        // Find all elements with the class \"multilang-begin\" or \"multilang-end\".\n        const multiLangElements = elements.querySelectorAll('.multilang-begin, .multilang-end');\n        multiLangElements.forEach(element => {\n            ed.dom.remove(element);\n        });\n        return;\n    }\n    const regexLang = /%lang/g;\n    let text = ed.selection.getContent();\n    // Selection is empty, just insert the lang opening and closing tag\n    // together with a space where the user may add the content.\n    if (trim(text) === '') {\n        // Event is set when the context menu was hit, here the editor lost the previously selected node. Therfore,\n        // don't do anything.\n        if (!isNull(event)) {\n            hideContentToolbar(event.target);\n            return;\n        }\n        let newtext = spanMultilangBegin.replace(regexLang, iso) + ' ' + spanMultilangEnd;\n        if (!mlangFilterExists(ed)) {\n            // No mlang filter, add the fallback class to the highlight spans so that these are translated\n            // to the standard <span class=\"multilang\"> elements.\n            newtext = newtext.replaceAll('mceNonEditable', 'mceNonEditable fallback');\n        }\n        ed.insertContent(newtext);\n        return;\n    }\n    // Hide context toolbar, because at any subsequent call the node is not selected anymore.\n    if (!isNull(event)) {\n        hideContentToolbar(event.target);\n    }\n    // No matter if we have syntax highlighting enabled or not, the spans around the language tags exist\n    // in the WYSIWYG mode. So check if we are on a special span that encapsulates the language tags. Search\n    // for the start span tag.\n    const span = getHighlightNodeFromSelect(ed, 'begin');\n    // If we have a span, then it's the opening tag, and we just replace this one with the new iso.\n    if (!isNull(span)) {\n        let replacement = spanMultilangBegin.replace(regexLang, iso);\n        if (span.classList.contains('fallback')) {\n            replacement = replacement.replace('mceNonEditable', 'mceNonEditable fallback');\n        }\n        ed.dom.setOuterHTML(span, replacement);\n        cleanupBogus(ed);\n        return;\n    }\n    // Check if we have language tags inside the selection:\n    if (text.indexOf('multilang-begin') !== -1 || text.indexOf('multilang-end') !== -1) {\n        ed.notificationManager.open({\n                text: _options.langInSelectionErrMsg,\n                type: 'error',\n            });\n        return;\n    }\n    const block = getBlockElement(text);\n    if (!isNull(block.el)) {\n        if (block.cnt === 1) {\n            // We have a block element selected, such as a hX or p tag. Then keep this tag and place the\n            // language tags inside but around the content of the block element.\n            let newtext = spanMultilangBegin.replace(regexLang, iso) + block.el.innerHTML + spanMultilangEnd;\n            if (!mlangFilterExists(ed)) { // No mlang filter, add the fallback class to the highlight spans.\n                newtext = newtext.replaceAll('mceNonEditable', 'mceNonEditable fallback');\n            }\n            block.el.innerHTML = newtext;\n            ed.selection.setContent(block.el.outerHTML);\n            return;\n        }\n        if (!mlangFilterExists(ed)) {\n            ed.notificationManager.open({\n                text: _options.multipleBlocksErrMsg,\n                type: 'error',\n            });\n            return;\n        }\n    }\n    // Not inside a lang tag, insert a new opening and closing tag with the selection inside.\n    let newtext = spanMultilangBegin.replace(regexLang, iso) + text + spanMultilangEnd;\n    if (!mlangFilterExists(ed)) { // No mlang filter, add the fallback class to the highlight spans.\n        newtext = newtext.replaceAll('mceNonEditable', 'mceNonEditable fallback');\n    }\n    ed.selection.setContent(newtext);\n};\n\nexport {\n    onInit,\n    onBeforeGetContent,\n    onFocus,\n    onSubmit,\n    onDelete,\n    applyLanguage\n};\n"],"names":["_isSubmit","_options","addVisualStyling","ed","content","getContent","doc","DOMParser","parseFromString","children","length","nodes","querySelectorAll","span","newSpan","spanMultilangBegin","replace","RegExp","getAttribute","innerHTML","spanMultilangEnd","insertAdjacentHTML","remove","getElementsByTagName","removeVisualStyling","forEach","t","dom","select","classList","contains","end","toRemove","nextSibling","push","nodeType","nodeValue","outerHTML","lang","match","newHTML","setOuterHTML","toLowerCase","getHighlightNodeFromSelect","search","getParents","selection","getStart","elm","counterpart","findClosestAncestor","findClosestSuccessor","node","nodeList","i","isMultilangTag","hideContentToolbar","el","Node","ELEMENT_NODE","indexOf","style","display","parentNode","options","Object","keys","key","setContent","addStyle","source_view","onClose","off","MutationObserver","mutations","obs","viewSrcModal","document","querySelector","addEventListener","event","action","target","dataset","includes","disconnect","on","observe","body","childList","subtree","no_events","isComposing","clientX","keyCode","nodeName","begin","preventDefault","cleanupBogus","p","parentElement","iso","contentDocument","element","regexLang","text","newtext","replaceAll","insertContent","replacement","notificationManager","open","langInSelectionErrMsg","type","block","result","cnt","firstChild","blockTags","tagName","toString","getBlockElement","multipleBlocksErrMsg"],"mappings":"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"}