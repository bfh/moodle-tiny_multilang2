{"version":3,"file":"htmlparser.min.js","sources":["../src/htmlparser.js"],"sourcesContent":["// This file is part of Moodle - https://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * Handling of the editor content to add and remove the visual styling and\n * helper nodes to modify language settings.\n *\n * @module      tiny_multilang2\n * @copyright   2024 Stephan Robotta <stephan.robotta@bfh.ch>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {spanMultilangBegin, spanMultilangEnd} from './constants';\n\n/**\n * This class is used to parse HTML content and call a callback function\n * when a tag is opened, closed or text is found.\n */\nclass HTMLParser {\n    constructor() {\n        this.onTagOpen = null;\n        this.onTagClose = null;\n        this.onText = null;\n        this.onComment = null;\n        this.onScript = null;\n        this.onStyle = null;\n        this.chunk = '';\n\n        /**\n         * Parser function that receives the HTML string matches tags, text and comments\n         * and calls the corresponding callback functions.\n         * @param {string} input The HTML content to parse.\n         */\n        this.parse = function(input) {\n            let content = input;\n            while (content.length > 0) {\n                // Find the next < with chars and some time later a >.\n                let match = content.match(/<[^>]*>/);\n                if (match) {\n                    let index = match.index;\n                    if (index > 0) {\n                        // The < was not at the beginning of the string.\n                        // All before the < is text.\n                        this.chunk = content.substring(0, index);\n                        content = content.substring(index);\n                        if (typeof this.onText === 'function') {\n                            this.onText(this.chunk);\n                        }\n                    }\n                    this.chunk = match[0];\n                    // First char is a / so the matched tag is a closing tag.\n                    if (match[0].charAt(1) === '/') {\n                        if (typeof this.onTagClose === 'function') {\n                            const tag = match[0].substring(2, match[0].length - 1).trim().toLowerCase();\n                            this.onTagClose(tag);\n                        }\n                    } else if (match[0].indexOf('<!--') === 0) {\n                        // We found the start of a comment.\n                        this.handleInlineCode('-->', content);\n                        if (typeof this.onComment === 'function') {\n                            this.onComment(this.chunk);\n                        }\n                    } else if (match[0].toLowerCase().indexOf('<script') === 0) {\n                        this.handleInlineCode('</script>', content);\n                        if (typeof this.onScript === 'function') {\n                            this.onScript(this.chunk);\n                        }\n                    } else if (match[0].toLowerCase().indexOf('<style') === 0) {\n                        this.handleInlineCode('</style>', content);\n                        if (typeof this.onStyle === 'function') {\n                            this.onStyle(this.chunk);\n                        }\n                    } else if (typeof this.onTagOpen === 'function') {\n                        // None of the above, so we have an opening tag.\n                        const attr1 = this.mapAttrs(match[0].match(/([\\w\\-_]+)=\"([^\"]*)\"/g));\n                        const attr2 = this.mapAttrs(match[0].match(/([\\w\\-_]+)='([^']*)'/g));\n                        const tag = match[0].match(/^<(\\w+)/);\n                        this.onTagOpen(tag[1].toLowerCase(), {...attr1, ...attr2});\n                    }\n                    // Remove the chunk from the content, that we just parsed and start from the\n                    // beginning again, to match the next tag.\n                    content = content.substring(this.chunk.length);\n                } else {\n                    // No more tags, so the rest is text.\n                    if (typeof this.onText === 'function') {\n                        this.onText(content);\n                    }\n                    this.chunk = content;\n                    content = '';\n                }\n            }\n        };\n\n        /**\n         * During the parsing process, this function returns the current chunk of the\n         * parsed HTML content. This is either text, an opening tag including attributes,\n         * a closing tag or a comment (including comment tags).\n         * @returns {string} The current chunk of the parsed HTML content.\n         */\n        this.getChunk = function() {\n            return this.chunk;\n        };\n\n        /**\n         * The function receives an array of attributes in the form of key=\"value\" pairs\n         * and returns an object with the key-value pairs.\n         * @param {Array} attrs An array of key=\"value\" pairs.\n         * @returns {Object} An object with the key-value pairs of the attributes.\n         */\n        this.mapAttrs = function(attrs) {\n            let res = {};\n            if (attrs) {\n                for (let i = 0; i < attrs.length; i++) {\n                    let [k, v] = attrs[i].split('=');\n                    res[k] = v ? v.substring(1, v.length) : null;\n                }\n            }\n            return res;\n        };\n\n        /**\n         * This function is used on tags where the content should remain unchanged. These\n         * are at the moment comments, script and style tags.\n         * @param {string} endTag\n         * @param {string} content\n         */\n        this.handleInlineCode = function(endTag, content) {\n            let end = content.toLowerCase().indexOf(endTag);\n            if (end === -1) {\n                end = content.length;\n            } else {\n                end += endTag.length;\n            }\n            this.chunk = content.substring(0, end);\n        };\n    }\n}\n\n/**\n * The parser function that receives the HTML content and parses it to add the\n * visual styling and helper nodes to modify language settings.\n * @param {string} html\n * @returns {string} The modified HTML content.\n */\nexport const parseEditorContent = function(html) {\n    let newHtml = '';\n    let mlang = 0;\n    let inClose = false;\n    const parser = new HTMLParser();\n\n    // Function to pass through comment, script and style elements.\n    const passThru = function(comment) {\n        newHtml += comment;\n    };\n\n    /**\n     * Callback function when an opening tag is found.\n     * @param {string} tag\n     * @param {object} attr\n     */\n    parser.onTagOpen = function(tag, attr) {\n        if (tag === 'span' && attr.class && attr.class.indexOf('multilang-begin') > -1) {\n            mlang++;\n        } else if (tag === 'span' && attr.class && attr.class.indexOf('multilang-end') > -1 &&\n            mlang > 0\n        ) {\n            mlang--;\n            inClose = true;\n        }\n        newHtml += parser.getChunk();\n    };\n\n    /**\n     * Callback function when a closing tag is found.\n     * @param {string} tag\n     */\n    parser.onTagClose = function(tag) {\n        if (tag === 'span' && inClose) {\n            inClose = false;\n        }\n        newHtml += parser.getChunk();\n    };\n\n    /**\n     * Callback function when text is found.\n     * @param {string} text\n     */\n    parser.onText = function(text) {\n        if (inClose) {\n            newHtml += text;\n            return;\n        }\n        const intermediateReplacements = [];\n        // eslint-disable-next-line no-constant-condition\n        while (1) {\n            const m = text.match(new RegExp('{\\\\s*mlang(\\\\s+([^}]+?))?\\\\s*}', 'i'));\n            if (!m) {\n                break;\n            }\n            const textBefore = text.substring(0, m.index);\n            const textAfter = text.substring(m.index + m[0].length);\n            let r = m[0];\n            if (!m[2]) {\n                if (mlang === 1) {\n                    r = spanMultilangEnd;\n                }\n                mlang--;\n            } else {\n                if (mlang === 0) {\n                    r = spanMultilangBegin.replace(new RegExp('%lang', 'g'), m[2]);\n                }\n                mlang++;\n            }\n            intermediateReplacements.push(r);\n            text = `${textBefore}___~~${intermediateReplacements.length}~~___${textAfter}`;\n        }\n        // Revert all placeholders back to the original {mlang} tags.\n        for (let i = 0; i < intermediateReplacements.length; i++) {\n            text = text.replace(`___~~${i + 1}~~___`, intermediateReplacements[i]);\n        }\n        newHtml += text;\n    };\n\n    /**\n     * Callback function when a comment is found.\n     * @param {string} comment\n     */\n    parser.onComment = passThru;\n    parser.onScript = passThru;\n    parser.onStyle = passThru;\n\n    // Parse the HTML content.\n    parser.parse(html);\n    // And return the modified content.\n    return newHtml;\n};\n"],"names":["HTMLParser","constructor","onTagOpen","onTagClose","onText","onComment","onScript","onStyle","chunk","parse","input","content","length","match","index","substring","this","charAt","tag","trim","toLowerCase","indexOf","handleInlineCode","attr1","mapAttrs","attr2","getChunk","attrs","res","i","k","v","split","endTag","end","html","newHtml","mlang","inClose","parser","passThru","comment","attr","class","text","intermediateReplacements","m","RegExp","textBefore","textAfter","r","spanMultilangBegin","replace","spanMultilangEnd","push"],"mappings":"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"}