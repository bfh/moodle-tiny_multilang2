{"version":3,"file":"htmlparser.min.js","sources":["../src/htmlparser.js"],"sourcesContent":["// This file is part of Moodle - https://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * Handling of the editor content to add and remove the visual styling and\n * helper nodes to modify language settings.\n *\n * @module      tiny_multilang2\n * @copyright   2024 Stephan Robotta <stephan.robotta@bfh.ch>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {spanMultilangBegin, spanMultilangEnd} from './constants';\n\n/**\n * This class is used to parse HTML content and call a callback function\n * when a tag is opened, closed or text is found.\n */\nclass HTMLParser {\n    constructor() {\n        this.onTagOpen = null;\n        this.onTagClose = null;\n        this.onText = null;\n        this.onComment = null;\n        this.chunk = '';\n\n        /**\n         * Parser function that receives the HTML string matches tags, text and comments\n         * and calls the corresponding callback functions.\n         * @param {string} input The HTML content to parse.\n         */\n        this.parse = function(input) {\n            let content = input;\n            while (content.length > 0) {\n                // Find the next < with chars and some time later a >.\n                let match = content.match(/<[^>]*>/);\n                if (match) {\n                    let index = match.index;\n                    if (index > 0) {\n                        // The < was not at the beginning of the string.\n                        // All before the < is text.\n                        this.chunk = content.substring(0, index);\n                        content = content.substring(index);\n                        if (typeof this.onText === 'function') {\n                            this.onText(this.chunk);\n                        }\n                    }\n                    this.chunk = match[0];\n                    // First char is a / so the matched tag is a closing tag.\n                    if (match[0].charAt(1) === '/') {\n                        if (typeof this.onTagClose === 'function') {\n                            const tag = match[0].substring(2, match[0].length - 1).trim().toLowerCase();\n                            this.onTagClose(tag);\n                        }\n                    } else if (match[0].indexOf('<!--') === 0) {\n                        // We found the start of a comment.\n                        let end = content.indexOf('-->');\n                        if (end === -1) {\n                            end = content.length;\n                        } else {\n                            end += 3;\n                        }\n                        this.chunk = content.substring(0, end);\n                        if (typeof this.onComment === 'function') {\n                            this.onComment(this.chunk);\n                        }\n                    } else if (typeof this.onTagOpen === 'function') {\n                        // None of the above, so we have an opening tag.\n                        const attr1 = this.mapAttrs(match[0].match(/([\\w\\-_]+)=\"([^\"]*)\"/g));\n                        const attr2 = this.mapAttrs(match[0].match(/([\\w\\-_]+)='([^']*)'/g));\n                        const tag = match[0].match(/^<(\\w+)/);\n                        this.onTagOpen(tag[1].toLowerCase(), {...attr1, ...attr2});\n                    }\n                    // Remove the chunk from the content, that we just parsed and start from the\n                    // beginning again, to match the next tag.\n                    content = content.substring(this.chunk.length);\n                } else {\n                    // No more tags, so the rest is text.\n                    if (typeof this.onText === 'function') {\n                        this.onText(content);\n                    }\n                    this.chunk = content;\n                    content = '';\n                }\n            }\n        };\n\n        /**\n         * During the parsing process, this function returns the current chunk of the\n         * parsed HTML content. This is either text, an opening tag including attributes,\n         * a closing tag or a comment (including comment tags).\n         * @returns {string} The current chunk of the parsed HTML content.\n         */\n        this.getChunk = function() {\n            return this.chunk;\n        };\n\n        /**\n         * The function receives an array of attributes in the form of key=\"value\" pairs\n         * and returns an object with the key-value pairs.\n         * @param {Array} attrs An array of key=\"value\" pairs.\n         * @returns {Object} An object with the key-value pairs of the attributes.\n         */\n        this.mapAttrs = function(attrs) {\n            let res = {};\n            if (attrs) {\n                for (let i = 0; i < attrs.length; i++) {\n                    let [k, v] = attrs[i].split('=');\n                    res[k] = v ? v.substring(1, v.length) : null;\n                }\n            }\n            return res;\n        };\n    }\n}\n\n/**\n * The parser function that receives the HTML content and parses it to add the\n * visual styling and helper nodes to modify language settings.\n * @param {string} html\n * @returns {string} The modified HTML content.\n */\nexport const parseEditorContent = function(html) {\n    let newHtml = '';\n    let mlang = 0;\n    let inClose = false;\n    const parser = new HTMLParser();\n\n    /**\n     * Callback function when an opening tag is found.\n     * @param {string} tag\n     * @param {object} attr\n     */\n    parser.onTagOpen = function(tag, attr) {\n        if (tag === 'span' && attr.class && attr.class.indexOf('multilang-begin') > -1) {\n            mlang++;\n        } else if (tag === 'span' && attr.class && attr.class.indexOf('multilang-end') > -1 &&\n            mlang > 0\n        ) {\n            mlang--;\n            inClose = true;\n        }\n        newHtml += parser.getChunk();\n    };\n\n    /**\n     * Callback function when a closing tag is found.\n     * @param {string} tag\n     */\n    parser.onTagClose = function(tag) {\n        if (tag === 'span' && inClose) {\n            inClose = false;\n        }\n        newHtml += parser.getChunk();\n    };\n\n    /**\n     * Callback function when text is found.\n     * @param {string} text\n     */\n    parser.onText = function(text) {\n        if (inClose) {\n            newHtml += text;\n            return;\n        }\n        const intermediateReplacements = [];\n        // eslint-disable-next-line no-constant-condition\n        while (1) {\n            const m = text.match(new RegExp('{\\\\s*mlang(\\\\s+([^}]+?))?\\\\s*}', 'i'));\n            if (!m) {\n                break;\n            }\n            const textBefore = text.substring(0, m.index);\n            const textAfter = text.substring(m.index + m[0].length);\n            let r = m[0];\n            if (!m[2]) {\n                if (mlang === 1) {\n                    r = spanMultilangEnd;\n                }\n                mlang--;\n            } else {\n                if (mlang === 0) {\n                    r = spanMultilangBegin.replace(new RegExp('%lang', 'g'), m[2]);\n                }\n                mlang++;\n            }\n            intermediateReplacements.push(r);\n            text = `${textBefore}___~~${intermediateReplacements.length}~~___${textAfter}`;\n        }\n        // Revert all placeholders back to the original {mlang} tags.\n        for (let i = 0; i < intermediateReplacements.length; i++) {\n            text = text.replace(`___~~${i + 1}~~___`, intermediateReplacements[i]);\n        }\n        newHtml += text;\n    };\n\n    /**\n     * Callback function when a comment is found.\n     * @param {string} comment\n     */\n    parser.onComment = function(comment) {\n        newHtml += comment;\n    };\n\n    // Parse the HTML content.\n    parser.parse(html);\n    // And return the modified content.\n    return newHtml;\n};\n"],"names":["HTMLParser","constructor","onTagOpen","onTagClose","onText","onComment","chunk","parse","input","content","length","match","index","substring","this","charAt","tag","trim","toLowerCase","indexOf","end","attr1","mapAttrs","attr2","getChunk","attrs","res","i","k","v","split","html","newHtml","mlang","inClose","parser","attr","class","text","intermediateReplacements","m","RegExp","textBefore","textAfter","r","spanMultilangBegin","replace","spanMultilangEnd","push","comment"],"mappings":";;;;;;;;;MA8BMA,WACFC,mBACSC,UAAY,UACZC,WAAa,UACbC,OAAS,UACTC,UAAY,UACZC,MAAQ,QAORC,MAAQ,SAASC,WACdC,QAAUD,WACPC,QAAQC,OAAS,GAAG,KAEnBC,MAAQF,QAAQE,MAAM,cACtBA,MAAO,KACHC,MAAQD,MAAMC,SACdA,MAAQ,SAGHN,MAAQG,QAAQI,UAAU,EAAGD,OAClCH,QAAUA,QAAQI,UAAUD,OACD,mBAAhBE,KAAKV,aACPA,OAAOU,KAAKR,aAGpBA,MAAQK,MAAM,GAEQ,MAAvBA,MAAM,GAAGI,OAAO,OACe,mBAApBD,KAAKX,WAA2B,OACjCa,IAAML,MAAM,GAAGE,UAAU,EAAGF,MAAM,GAAGD,OAAS,GAAGO,OAAOC,mBACzDf,WAAWa,WAEjB,GAAiC,IAA7BL,MAAM,GAAGQ,QAAQ,WAAe,KAEnCC,IAAMX,QAAQU,QAAQ,WACb,IAATC,IACAA,IAAMX,QAAQC,OAEdU,KAAO,OAENd,MAAQG,QAAQI,UAAU,EAAGO,KACJ,mBAAnBN,KAAKT,gBACPA,UAAUS,KAAKR,YAErB,GAA8B,mBAAnBQ,KAAKZ,UAA0B,OAEvCmB,MAAQP,KAAKQ,SAASX,MAAM,GAAGA,MAAM,0BACrCY,MAAQT,KAAKQ,SAASX,MAAM,GAAGA,MAAM,0BACrCK,IAAML,MAAM,GAAGA,MAAM,gBACtBT,UAAUc,IAAI,GAAGE,cAAe,IAAIG,SAAUE,QAIvDd,QAAUA,QAAQI,UAAUC,KAAKR,MAAMI,YAGZ,mBAAhBI,KAAKV,aACPA,OAAOK,cAEXH,MAAQG,QACbA,QAAU,UAWjBe,SAAW,kBACLV,KAAKR,YASXgB,SAAW,SAASG,WACjBC,IAAM,MACND,UACK,IAAIE,EAAI,EAAGA,EAAIF,MAAMf,OAAQiB,IAAK,KAC9BC,EAAGC,GAAKJ,MAAME,GAAGG,MAAM,KAC5BJ,IAAIE,GAAKC,EAAIA,EAAEhB,UAAU,EAAGgB,EAAEnB,QAAU,YAGzCgB,kCAWe,SAASK,UACnCC,QAAU,GACVC,MAAQ,EACRC,SAAU,QACRC,OAAS,IAAInC,kBAOnBmC,OAAOjC,UAAY,SAASc,IAAKoB,MACjB,SAARpB,KAAkBoB,KAAKC,OAASD,KAAKC,MAAMlB,QAAQ,oBAAsB,EACzEc,QACe,SAARjB,KAAkBoB,KAAKC,OAASD,KAAKC,MAAMlB,QAAQ,kBAAoB,GAC9Ec,MAAQ,IAERA,QACAC,SAAU,GAEdF,SAAWG,OAAOX,YAOtBW,OAAOhC,WAAa,SAASa,KACb,SAARA,KAAkBkB,UAClBA,SAAU,GAEdF,SAAWG,OAAOX,YAOtBW,OAAO/B,OAAS,SAASkC,SACjBJ,oBACAF,SAAWM,YAGTC,yBAA2B,UAEvB,OACAC,EAAIF,KAAK3B,MAAM,IAAI8B,OAAO,iCAAkC,UAC7DD,cAGCE,WAAaJ,KAAKzB,UAAU,EAAG2B,EAAE5B,OACjC+B,UAAYL,KAAKzB,UAAU2B,EAAE5B,MAAQ4B,EAAE,GAAG9B,YAC5CkC,EAAIJ,EAAE,GACLA,EAAE,IAMW,IAAVP,QACAW,EAAIC,8BAAmBC,QAAQ,IAAIL,OAAO,QAAS,KAAMD,EAAE,KAE/DP,UARc,IAAVA,QACAW,EAAIG,6BAERd,SAOJM,yBAAyBS,KAAKJ,GAC9BN,eAAUI,2BAAkBH,yBAAyB7B,uBAAciC,eAGlE,IAAIhB,EAAI,EAAGA,EAAIY,yBAAyB7B,OAAQiB,IACjDW,KAAOA,KAAKQ,uBAAgBnB,EAAI,WAAUY,yBAAyBZ,IAEvEK,SAAWM,MAOfH,OAAO9B,UAAY,SAAS4C,SACxBjB,SAAWiB,SAIfd,OAAO5B,MAAMwB,MAENC"}